"0","cat(""\n=== ENHANCED CLUSTERING WITH CLUSTERBENCHSTATS ===\n"")"
"1","
=== ENHANCED CLUSTERING WITH CLUSTERBENCHSTATS ===
"
"0","# Clean the data before distance calculation"
"0","clean_clustering_data <- function(data) {"
"0","  clean_data <- as.data.frame(data)"
"0","  "
"0","  # Convert all haven_labelled columns"
"0","  for (col_name in names(clean_data)) {"
"0","    if (inherits(clean_data[[col_name]], ""haven_labelled"")) {"
"0","      clean_data[[col_name]] <- as.numeric(clean_data[[col_name]])"
"0","    }"
"0","  }"
"0","  "
"0","  # Remove any list columns"
"0","  list_cols <- sapply(clean_data, is.list)"
"0","  if (any(list_cols)) {"
"0","    clean_data <- clean_data[, !list_cols, drop = FALSE]"
"0","  }"
"0","  "
"0","  return(clean_data)"
"0","}"
"0",""
"0","# Calculate all three distance matrices using mdist"
"0","calculate_cycle_distances_enhanced <- function(cycle_data_info, distance_methods) {"
"0","  "
"0","  cycle_name <- cycle_data_info$cycle"
"0","  cat(sprintf(""\n→ Calculating distance matrices for PISA %s...\n"", cycle_name))"
"0","  "
"0","  # Prepare data"
"0","  distance_data <- cycle_data_info$data[, cycle_data_info$clustering_vars, with = FALSE]"
"0","  distance_data <- na.omit(distance_data)"
"0","  "
"0","  # Clean the data to remove haven_labelled issues"
"0","  distance_data <- clean_clustering_data(distance_data)"
"0","  "
"0","  # Handle missing values"
"0","  for (var in names(distance_data)) {"
"0","    if (any(is.na(distance_data[[var]]))) {"
"0","      if (is.factor(distance_data[[var]])) {"
"0","        mode_val <- names(sort(table(distance_data[[var]]), decreasing = TRUE))[1]"
"0","        distance_data[is.na(distance_data[[var]]), var] <- mode_val"
"0","      } else {"
"0","        median_val <- median(distance_data[[var]], na.rm = TRUE)"
"0","        distance_data[is.na(distance_data[[var]]), var] <- median_val"
"0","      }"
"0","    }"
"0","  }"
"0","  "
"0","  cycle_distance_matrices <- list()"
"0","  "
"0","  for (method_name in names(distance_methods)) {"
"0","    cat(sprintf(""  → %s..."", method_name))"
"0","    "
"0","    method_info <- distance_methods[[method_name]]"
"0","    "
"0","    tryCatch({"
"0","      start_time <- Sys.time()"
"0","      "
"0","      # Use manydist with your original parameters"
"0","      dist_matrix <- do.call(manydist::mdist, c(list(x = distance_data), method_info$params))"
"0","      "
"0","      end_time <- Sys.time()"
"0","      calc_time <- as.numeric(difftime(end_time, start_time, units = ""secs""))"
"0","      "
"0","      cycle_distance_matrices[[method_name]] <- list("
"0","        matrix = as.dist(dist_matrix),  # Convert to dist object"
"0","        method = method_info$name,"
"0","        description = method_info$description,"
"0","        calculation_time = calc_time,"
"0","        params = method_info$params,"
"0","        cycle = cycle_name"
"0","      )"
"0","      "
"0","      cat(sprintf("" %.1fs ✓\n"", calc_time))"
"0","      "
"0","    }, error = function(e) {"
"0","      cat(sprintf("" ERROR: %s\n"", e$message))"
"0","      cat(""  → DID NOTHING...\n"")"
"0","      "
"0","    })"
"0","  }"
"0","  "
"0","  return(cycle_distance_matrices)"
"0","}"
"0",""
"0","# Education-specific weight development"
"0","develop_educational_weights <- function(available_stats, purpose = ""policy"") {"
"0","  "
"0","  cat(sprintf(""  → Developing %s weights for %d available statistics\n"", purpose, length(available_stats)))"
"0","  "
"0","  # Initialize all weights to a small default value (not zero)"
"0","  weights <- rep(0.1, length(available_stats))"
"0","  names(weights) <- available_stats"
"0","  "
"0","  # Print available statistics for debugging"
"0","  cat(""    Available statistics:"", paste(available_stats, collapse = "", ""), ""\n"")"
"0","  "
"0","  if (purpose == ""policy"") {"
"0","    # Educational Policy Index (Strategic Level)"
"0","    for (stat in available_stats) {"
"0","      if (grepl(""entropy"", stat, ignore.case = TRUE)) {"
"0","        weights[stat] <- 3  # High entropy weight"
"0","      } else if (grepl(""within|ave\\.within|homogeneity"", stat, ignore.case = TRUE)) {"
"0","        weights[stat] <- 1.0  # High within-cluster homogeneity"
"0","      } else if (grepl(""boot|stability"", stat, ignore.case = TRUE)) {"
"0","        weights[stat] <- 1.2  # High stability"
"0","      } else if (grepl(""silhouette|silwidth|asw"", stat, ignore.case = TRUE)) {"
"0","        weights[stat] <- 0.8  # Medium silhouette"
"0","      } else if (grepl(""separation|sep|minsep"", stat, ignore.case = TRUE)) {"
"0","        weights[stat] <- 0.6  # Medium separation"
"0","      } else if (grepl(""gamma|pearson"", stat, ignore.case = TRUE)) {"
"0","        weights[stat] <- 0.7  # Structural validity"
"0","      }"
"0","    }"
"0","    "
"0","  } else if (purpose == ""intervention"") {"
"0","    # Educational Intervention Index (Operational Level)"
"0","    for (stat in available_stats) {"
"0","      if (grepl(""boot|stability"", stat, ignore.case = TRUE)) {"
"0","        weights[stat] <- 1.8  # Highest stability"
"0","      } else if (grepl(""silhouette|silwidth|asw"", stat, ignore.case = TRUE)) {"
"0","        weights[stat] <- 1.5  # High precision"
"0","      } else if (grepl(""within|ave\\.within|homogeneity"", stat, ignore.case = TRUE)) {"
"0","        weights[stat] <- 1.3  # High homogeneity"
"0","      } else if (grepl(""entropy"", stat, ignore.case = TRUE)) {"
"0","        weights[stat] <- 1.4  # Actionability"
"0","      } else if (grepl(""separation|sep|minsep"", stat, ignore.case = TRUE)) {"
"0","        weights[stat] <- 0.4  # Lower separation priority"
"0","      }"
"0","    }"
"0","    "
"0","  } else if (purpose == ""equity"") {"
"0","    # Educational Equity Index (Social Justice Level)"
"0","    for (stat in available_stats) {"
"0","      if (grepl(""separation|sep|dunn|minsep"", stat, ignore.case = TRUE)) {"
"0","        weights[stat] <- 1.5  # High separation"
"0","      } else if (grepl(""entropy"", stat, ignore.case = TRUE)) {"
"0","        weights[stat] <- 1.4  # Balanced representation"
"0","      } else if (grepl(""silhouette|silwidth|ch|calinski|asw"", stat, ignore.case = TRUE)) {"
"0","        weights[stat] <- 1.2  # Meaningful differences"
"0","      } else if (grepl(""boot|stability"", stat, ignore.case = TRUE)) {"
"0","        weights[stat] <- 0.8  # Medium stability"
"0","      }"
"0","    }"
"0","  }"
"0","  "
"0","  cat(sprintf(""    Weights assigned - non-default weights: %d\n"", "
"0","              sum(weights != 0.1)))"
"0","  "
"0","  return(weights)"
"0","}"
"0",""
"0",""
"0","# FIXED: Extract statistics from clusterbenchstats - handles different structures"
"0","extract_clusterbenchstats_matrix <- function(cbs_result) {"
"0","  "
"0","  # Check if we have the sstat component (standardized statistics)"
"0","  if (is.null(cbs_result$sstat)) {"
"0","    # Try qstat as fallback"
"0","    if (!is.null(cbs_result$qstat)) {"
"0","      cat(""    Using qstat (non-standardized) instead of sstat\n"")"
"0","      stat_component <- cbs_result$qstat"
"0","    } else {"
"0","      cat(""    No sstat or qstat component found in results\n"")"
"0","      return(NULL)"
"0","    }"
"0","  } else {"
"0","    stat_component <- cbs_result$sstat"
"0","  }"
"0","  "
"0","  # Get metadata"
"0","  methods <- stat_component$name  # Use 'name' for display names (Ward, Average, etc.)"
"0","  if (is.null(methods)) methods <- stat_component$method"
"0","  G_values <- stat_component$minG:stat_component$maxG"
"0","  stat_names <- stat_component$statistics"
"0","  "
"0","  # Create empty matrix"
"0","  n_rows <- length(methods) * length(G_values)"
"0","  stats_matrix <- matrix(NA, nrow = n_rows, ncol = length(stat_names))"
"0","  colnames(stats_matrix) <- stat_names"
"0","  "
"0","  # Row names using the display names"
"0","  row_names <- character(n_rows)"
"0","  row_idx <- 1"
"0","  for (method in methods) {"
"0","    for (g in G_values) {"
"0","      row_names[row_idx] <- paste(method, g, sep = ""."")"
"0","      row_idx <- row_idx + 1"
"0","    }"
"0","  }"
"0","  rownames(stats_matrix) <- row_names"
"0","  "
"0","  # Fill the matrix - NEW LOGIC to handle different structures"
"0","  row_idx <- 1"
"0","  "
"0","  for (method_idx in 1:length(methods)) {"
"0","    method_data <- stat_component[[method_idx]]"
"0","    "
"0","    if (is.list(method_data)) {"
"0","      # The structure can vary:"
"0","      # - For small G ranges (like 3-6): positions 2-5 have stats for G=3,4,5,6"
"0","      # - For larger G ranges (like 8-12): need to map differently"
"0","      "
"0","      # First, figure out which positions have actual statistics"
"0","      stats_positions <- c()"
"0","      for (pos in 1:length(method_data)) {"
"0","        if (is.list(method_data[[pos]]) && length(method_data[[pos]]) > 0) {"
"0","          # Check if this looks like a statistics list"
"0","          if (length(intersect(names(method_data[[pos]]), stat_names)) > 0) {"
"0","            stats_positions <- c(stats_positions, pos)"
"0","          }"
"0","        }"
"0","      }"
"0","      "
"0","      # Now map the positions to G values"
"0","      if (length(stats_positions) == length(G_values)) {"
"0","        # Perfect match - use positions directly"
"0","        for (i in seq_along(G_values)) {"
"0","          g_stats <- method_data[[stats_positions[i]]]"
"0","          "
"0","          if (is.list(g_stats) && length(g_stats) > 0) {"
"0","            for (col_idx in 1:length(stat_names)) {"
"0","              stat_name <- stat_names[col_idx]"
"0","              if (stat_name %in% names(g_stats)) {"
"0","                value <- g_stats[[stat_name]]"
"0","                if (is.numeric(value) && length(value) == 1 && is.finite(value)) {"
"0","                  stats_matrix[row_idx, col_idx] <- value"
"0","                }"
"0","              }"
"0","            }"
"0","          }"
"0","          row_idx <- row_idx + 1"
"0","        }"
"0","      } else {"
"0","        # Try the old logic (position = g_idx + 1)"
"0","        for (g_idx in seq_along(G_values)) {"
"0","          pos <- g_idx + 1"
"0","          if (pos <= length(method_data)) {"
"0","            g_stats <- method_data[[pos]]"
"0","            "
"0","            if (is.list(g_stats) && length(g_stats) > 0) {"
"0","              for (col_idx in 1:length(stat_names)) {"
"0","                stat_name <- stat_names[col_idx]"
"0","                if (stat_name %in% names(g_stats)) {"
"0","                  value <- g_stats[[stat_name]]"
"0","                  if (is.numeric(value) && length(value) == 1 && is.finite(value)) {"
"0","                    stats_matrix[row_idx, col_idx] <- value"
"0","                  }"
"0","                }"
"0","              }"
"0","            }"
"0","          }"
"0","          row_idx <- row_idx + 1"
"0","        }"
"0","      }"
"0","    } else {"
"0","      row_idx <- row_idx + length(G_values)"
"0","    }"
"0","  }"
"0","  "
"0","  # Remove all-NA rows (if any)"
"0","  valid_rows <- rowSums(!is.na(stats_matrix)) > 0"
"0","  if (sum(valid_rows) == 0) {"
"0","    cat(""    ✗ No valid statistics found\n"")"
"0","    return(NULL)"
"0","  }"
"0","  "
"0","  return(stats_matrix[valid_rows, , drop = FALSE])"
"0","}"
"0",""
"0","# Also add a diagnostic function to check what's in the clusterbenchstats result"
"0","diagnose_clusterbenchstats <- function(cbs_result, name = ""Result"") {"
"0","  cat(sprintf(""\nDiagnosing %s:\n"", name))"
"0","  "
"0","  if (is.null(cbs_result)) {"
"0","    cat(""  Result is NULL\n"")"
"0","    return()"
"0","  }"
"0","  "
"0","  cat(sprintf(""  Main components: %s\n"", paste(names(cbs_result), collapse = "", "")))"
"0","  "
"0","  if (!is.null(cbs_result$sstat)) {"
"0","    cat(""  sstat structure:\n"")"
"0","    cat(sprintf(""    Names: %s\n"", paste(names(cbs_result$sstat), collapse = "", "")))"
"0","    cat(sprintf(""    Methods: %s\n"", paste(cbs_result$sstat$name, collapse = "", "")))"
"0","    cat(sprintf(""    G range: %d-%d\n"", cbs_result$sstat$minG, cbs_result$sstat$maxG))"
"0","    "
"0","    # Check first method's data"
"0","    if (length(cbs_result$sstat) > 0 && is.list(cbs_result$sstat[[1]])) {"
"0","      cat(sprintf(""    First method has %d elements\n"", length(cbs_result$sstat[[1]])))"
"0","      "
"0","      # Check if stats are actually there"
"0","      for (i in 2:min(4, length(cbs_result$sstat[[1]]))) {"
"0","        if (is.list(cbs_result$sstat[[1]][[i]])) {"
"0","          cat(sprintf(""      Element %d has %d statistics\n"", i, length(cbs_result$sstat[[1]][[i]])))"
"0","        }"
"0","      }"
"0","    }"
"0","  }"
"0","  "
"0","  if (!is.null(cbs_result$qstat)) {"
"0","    cat(""  qstat available (non-standardized stats)\n"")"
"0","  }"
"0","}"
"0",""
"0","find_best_across_distances_FIXED <- function(distance_results, cycle_name) {"
"0","  "
"0","  all_solutions <- list("
"0","    policy = list(),"
"0","    intervention = list(),"
"0","    equity = list()"
"0","  )"
"0","  "
"0","  # Collect solutions from all distance methods"
"0","  for (dist_method in names(distance_results)) {"
"0","    if (!is.null(distance_results[[dist_method]])) {"
"0","      "
"0","      cat(sprintf(""  → Processing %s distance method...\n"", dist_method))"
"0","      "
"0","      # Get available statistics from macro and micro analyses"
"0","      macro_analysis <- distance_results[[dist_method]]$macro_analysis"
"0","      micro_analysis <- distance_results[[dist_method]]$micro_analysis"
"0","      "
"0","      # Extract statistics matrices"
"0","      macro_stats_matrix <- NULL"
"0","      micro_stats_matrix <- NULL"
"0","      "
"0","      if (!is.null(macro_analysis)) {"
"0","        macro_stats_matrix <- extract_clusterbenchstats_matrix(macro_analysis)"
"0","      }"
"0","      "
"0","      if (!is.null(micro_analysis)) {"
"0","        micro_stats_matrix <- extract_clusterbenchstats_matrix(micro_analysis)"
"0","      }"
"0","      "
"0","      # Process macro statistics for policy and equity"
"0","      if (!is.null(macro_stats_matrix)) {"
"0","        # Apply education-specific weights"
"0","        available_stats <- colnames(macro_stats_matrix)"
"0","        policy_weights <- develop_educational_weights(available_stats, ""policy"")"
"0","        equity_weights <- develop_educational_weights(available_stats, ""equity"")"
"0","        "
"0","        # Calculate weighted scores"
"0","        policy_scores <- apply(macro_stats_matrix, 1, function(row) {"
"0","          if (all(is.na(row))) return(NA)"
"0","          row[!is.finite(row)] <- NA"
"0","          valid_indices <- !is.na(row)"
"0","          if (sum(valid_indices) == 0) return(NA)"
"0","          weighted.mean(row[valid_indices], policy_weights[valid_indices], na.rm = TRUE)"
"0","        })"
"0","        "
"0","        equity_scores <- apply(macro_stats_matrix, 1, function(row) {"
"0","          if (all(is.na(row))) return(NA)"
"0","          row[!is.finite(row)] <- NA"
"0","          valid_indices <- !is.na(row)"
"0","          if (sum(valid_indices) == 0) return(NA)"
"0","          weighted.mean(row[valid_indices], equity_weights[valid_indices], na.rm = TRUE)"
"0","        })"
"0","        "
"0","        # Store best solutions"
"0","        if (length(policy_scores) > 0 && any(!is.na(policy_scores))) {"
"0","          best_policy_idx <- which.max(policy_scores)"
"0","          best_policy_name <- names(policy_scores)[best_policy_idx]"
"0","          "
"0","          all_solutions$policy[[dist_method]] <- list("
"0","            score = policy_scores[best_policy_idx],"
"0","            solution = best_policy_name,"
"0","            distance_method = dist_method,"
"0","            statistics = macro_stats_matrix[best_policy_name, ]"
"0","          )"
"0","        }"
"0","        "
"0","        if (length(equity_scores) > 0 && any(!is.na(equity_scores))) {"
"0","          best_equity_idx <- which.max(equity_scores)"
"0","          best_equity_name <- names(equity_scores)[best_equity_idx]"
"0","          "
"0","          all_solutions$equity[[dist_method]] <- list("
"0","            score = equity_scores[best_equity_idx],"
"0","            solution = best_equity_name,"
"0","            distance_method = dist_method,"
"0","            statistics = macro_stats_matrix[best_equity_name, ]"
"0","          )"
"0","        }"
"0","      }"
"0","      "
"0","      # Process micro analysis for intervention"
"0","      if (!is.null(micro_stats_matrix)) {"
"0","        available_stats <- colnames(micro_stats_matrix)"
"0","        intervention_weights <- develop_educational_weights(available_stats, ""intervention"")"
"0","        "
"0","        intervention_scores <- apply(micro_stats_matrix, 1, function(row) {"
"0","          if (all(is.na(row))) return(NA)"
"0","          row[!is.finite(row)] <- NA"
"0","          valid_indices <- !is.na(row)"
"0","          if (sum(valid_indices) == 0) return(NA)"
"0","          weighted.mean(row[valid_indices], intervention_weights[valid_indices], na.rm = TRUE)"
"0","        })"
"0","        "
"0","        if (length(intervention_scores) > 0 && any(!is.na(intervention_scores))) {"
"0","          best_intervention_idx <- which.max(intervention_scores)"
"0","          best_intervention_name <- names(intervention_scores)[best_intervention_idx]"
"0","          "
"0","          all_solutions$intervention[[dist_method]] <- list("
"0","            score = intervention_scores[best_intervention_idx],"
"0","            solution = best_intervention_name,"
"0","            distance_method = dist_method,"
"0","            statistics = micro_stats_matrix[best_intervention_name, ]"
"0","          )"
"0","        }"
"0","      }"
"0","    }"
"0","  }"
"0","  "
"0","  # Find overall best for each purpose"
"0","  best_overall <- list()"
"0","  "
"0","  for (purpose in c(""policy"", ""intervention"", ""equity"")) {"
"0","    if (length(all_solutions[[purpose]]) > 0) {"
"0","      scores <- sapply(all_solutions[[purpose]], function(x) x$score)"
"0","      best_dist_method <- names(scores)[which.max(scores)]"
"0","      best_overall[[purpose]] <- all_solutions[[purpose]][[best_dist_method]]"
"0","      "
"0","      cat(sprintf(""  ✓ Best %s solution: %s using %s (Score: %.3f)\n"", "
"0","                  purpose, best_overall[[purpose]]$solution, "
"0","                  best_overall[[purpose]]$distance_method, "
"0","                  best_overall[[purpose]]$score))"
"0","    } else {"
"0","      cat(sprintf(""  ✗ No %s solution found\n"", purpose))"
"0","    }"
"0","  }"
"0","  "
"0","  # Return the results - THIS WAS THE MISSING PART"
"0","  return(best_overall)"
"0","}"
"0",""
"0","# The issue is likely in the find_best_across_distances_WORKING function"
"0","# Let's create a simplified version that will work reliably"
"0","find_best_solutions_simplified <- function(distance_results, cycle_name) {"
"0","  best_solutions <- list(policy = NULL, intervention = NULL, equity = NULL)"
"0","  "
"0","  # For each distance method, extract the best solutions"
"0","  for (dist_method in names(distance_results)) {"
"0","    dist_result <- distance_results[[dist_method]]"
"0","    "
"0","    # Extract macro statistics if available"
"0","    if (!is.null(dist_result$macro_analysis)) {"
"0","      macro_stats <- extract_clusterbenchstats_matrix(dist_result$macro_analysis)"
"0","      "
"0","      if (!is.null(macro_stats)) {"
"0","        # Calculate simple average score for policy and equity"
"0","        policy_scores <- rowMeans(macro_stats, na.rm = TRUE)"
"0","        equity_scores <- rowMeans(macro_stats[, c(""minsep"", ""asw"", ""dindex"", ""entropy"")], na.rm = TRUE)"
"0","        "
"0","        # Find best solutions"
"0","        best_policy <- names(which.max(policy_scores))"
"0","        best_equity <- names(which.max(equity_scores))"
"0","        "
"0","        # Store if better than current best"
"0","        if (is.null(best_solutions$policy) || "
"0","            policy_scores[best_policy] > best_solutions$policy$score) {"
"0","          best_solutions$policy <- list("
"0","            solution = best_policy,"
"0","            score = policy_scores[best_policy],"
"0","            distance_method = dist_method"
"0","          )"
"0","        }"
"0","        "
"0","        if (is.null(best_solutions$equity) || "
"0","            equity_scores[best_equity] > best_solutions$equity$score) {"
"0","          best_solutions$equity <- list("
"0","            solution = best_equity,"
"0","            score = equity_scores[best_equity],"
"0","            distance_method = dist_method"
"0","          )"
"0","        }"
"0","      }"
"0","    }"
"0","    "
"0","    # Extract micro statistics if available"
"0","    if (!is.null(dist_result$micro_analysis)) {"
"0","      micro_stats <- extract_clusterbenchstats_matrix(dist_result$micro_analysis)"
"0","      "
"0","      if (!is.null(micro_stats)) {"
"0","        # Calculate simple average score for intervention"
"0","        intervention_scores <- rowMeans(micro_stats, na.rm = TRUE)"
"0","        best_intervention <- names(which.max(intervention_scores))"
"0","        "
"0","        # Store if better than current best"
"0","        if (is.null(best_solutions$intervention) || "
"0","            intervention_scores[best_intervention] > best_solutions$intervention$score) {"
"0","          best_solutions$intervention <- list("
"0","            solution = best_intervention,"
"0","            score = intervention_scores[best_intervention],"
"0","            distance_method = dist_method"
"0","          )"
"0","        }"
"0","      }"
"0","    }"
"0","  }"
"0","  "
"0","  return(best_solutions)"
"0","}"
"0",""
"0","# Enhanced clustering function using clusterbenchstats with multiple distances"
"0","perform_educational_clustering_official <- function(cycle_data, cycle_name) {"
"0","  "
"0","  cat(sprintf(""\n=== CLUSTERBENCHSTATS ANALYSIS: PISA %s ===\n"", cycle_name))"
"0","  "
"0","  # Step 1: Calculate all three distance matrices"
"0","  cycle_distances <- calculate_cycle_distances_enhanced(cycle_data, DISTANCE_METHODS)"
"0","  "
"0","  # Step 2: Configure clustering methods (ALL DIST-COMPATIBLE)"
"0","  # IMPORTANT: Define these BEFORE the for loop"
"0","  clustermethod <- c(""disthclustCBI"", ""disthclustCBI"", ""disthclustCBI"", ""pamkCBI"")"
"0","  "
"0","  # Step 3: Configure method parameters"
"0","  clustermethodpars <- list()"
"0","  clustermethodpars[[1]] <- list(method = ""ward.D2"")"
"0"," # clustermethodpars[[2]] <- list(method = ""average"")"
"0","  clustermethodpars[[2]] <- list(method = ""ward.D2"")"
"0","  clustermethodpars[[3]] <- list(method = ""ward.D2"")"
"0","  clustermethodpars[[4]] <- list(diss = TRUE, usepam = TRUE)  # PAM with dissimilarity matrix"
"0","  "
"0","  # Step 4: Method identification"
"0","  methodnames <- c(""Ward"", ""Complete"", ""Complete"", ""PAM"")"
"0","  "
"0","  "
"0","  # Step 5: Distance method specification"
"0","  distmethod <- rep(TRUE, length(clustermethod))"
"0","  ncinput <- rep(TRUE, length(clustermethod))"
"0","  "
"0","  # Step 6: Define cluster ranges"
"0","  G_macro <- CYCLE_CLUSTERING_PARAMS$macro$k_min:CYCLE_CLUSTERING_PARAMS$macro$k_max"
"0","  G_micro <- CYCLE_CLUSTERING_PARAMS$micro$k_min:CYCLE_CLUSTERING_PARAMS$micro$k_max"
"0","  "
"0","  # Step 7: Run clustering analysis for each distance method"
"0","  distance_results <- list()"
"0","  "
"0","  for (dist_method_name in names(cycle_distances)) {"
"0","    if (!is.null(cycle_distances[[dist_method_name]])) {"
"0","      "
"0","      cat(sprintf(""\n→ Running clustering with %s distance...\n"", dist_method_name))"
"0","      "
"0","      dist_matrix <- cycle_distances[[dist_method_name]]$matrix"
"0","      "
"0","      # Initialize results for this distance method"
"0","      cbs_macro <- NULL"
"0","      cbs_micro <- NULL"
"0","      "
"0","      # Run macro-level analysis"
"0","      cat(""  → Macro-level clustering...\n"")"
"0","      tryCatch({"
"0","        # All variables are now in scope"
"0","        cbs_macro <- clusterbenchstats("
"0","          data = dist_matrix,"
"0","          G = G_macro,"
"0","          diss = TRUE,"
"0","          scaling = FALSE,"
"0","          clustermethod = clustermethod,"
"0","          methodnames = methodnames,"
"0","          distmethod = distmethod,"
"0","          ncinput = ncinput,"
"0","          clustermethodpars = clustermethodpars,"
"0","          npstats = FALSE,"
"0","          useboot = FALSE,"
"0","          trace = FALSE,"
"0","          useallmethods = FALSE,"
"0","          useallg = FALSE,"
"0","          nnruns = 2,"
"0","          kmruns = 2,"
"0","          fnruns = 2,"
"0","          avenruns = 2"
"0","        )"
"0","        "
"0","        cat(""    ✓ Macro clustering completed\n"")"
"0","        "
"0","      }, error = function(e) {"
"0","        cat(sprintf(""    ✗ Macro clustering failed: %s\n"", e$message))"
"0","        # cbs_macro already initialized as NULL"
"0","      })"
"0","      "
"0","      # Run micro-level analysis"
"0","      cat(""  → Micro-level clustering...\n"")"
"0","      tryCatch({"
"0","        cbs_micro <- clusterbenchstats("
"0","          data = dist_matrix,"
"0","          G = G_micro,"
"0","          diss = TRUE,"
"0","          scaling = FALSE,"
"0","          clustermethod = clustermethod,"
"0","          methodnames = methodnames,"
"0","          distmethod = distmethod,"
"0","          ncinput = ncinput,"
"0","          clustermethodpars = clustermethodpars,"
"0","          npstats = FALSE,"
"0","          useboot = FALSE,"
"0","          trace = FALSE,"
"0","          useallmethods = FALSE,"
"0","          useallg = FALSE,"
"0","          nnruns = 2,"
"0","          kmruns = 2,"
"0","          fnruns = 2,"
"0","          avenruns = 2"
"0","        )"
"0","        "
"0","        cat(""    ✓ Micro clustering completed\n"")"
"0","        "
"0","      }, error = function(e) {"
"0","        cat(sprintf(""    ✗ Micro clustering failed: %s\n"", e$message))"
"0","        # cbs_micro already initialized as NULL"
"0","      })"
"0","      "
"0","      # Store results for this distance method"
"0","      distance_results[[dist_method_name]] <- list("
"0","        macro_analysis = cbs_macro,"
"0","        micro_analysis = cbs_micro,"
"0","        distance_info = cycle_distances[[dist_method_name]]"
"0","      )"
"0","    }"
"0","  }"
"0","  "
"0","  # Step 8: Find best solutions across all distance methods"
"0","  cat(""\n→ Finding optimal solutions across all distance methods...\n"")"
"0","  "
"0","  # Replace the call to find_best_across_distances_WORKING with:"
"0","  best_solutions <- find_best_solutions_simplified(distance_results, cycle_name)"
"0","  "
"0","  return(list("
"0","    cycle = cycle_name,"
"0","    data_info = list("
"0","      n_students = nrow(na.omit(cycle_data$data[, cycle_data$clustering_vars, with = FALSE])),"
"0","      n_variables = length(cycle_data$clustering_vars),"
"0","      continuous_vars = cycle_data$continuous_vars,"
"0","      categorical_vars = cycle_data$categorical_vars"
"0","    ),"
"0","    distance_results = distance_results,"
"0","    optimal_solutions = best_solutions,"
"0","    distance_matrices = cycle_distances"
"0","  ))"
"0","}"
"0",""
"0","cat(""✓ Enhanced clustering functions with clusterbenchstats loaded\n"")"
"1","✓ Enhanced clustering functions with clusterbenchstats loaded
"

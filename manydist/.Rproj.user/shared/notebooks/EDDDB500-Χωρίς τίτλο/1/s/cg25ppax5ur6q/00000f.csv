"0","cat(""\\n=== CALCULATING COMPOSITE CLUSTERING VALIDITY INDEXES ===\\n"")"
"1","\n=== CALCULATING COMPOSITE CLUSTERING VALIDITY INDEXES ===\n"
"0","# Extract all quality metrics for calibration"
"0","extract_quality_metrics <- function(evaluations) {"
"0","  "
"0","  metrics_data <- data.frame()"
"0","  "
"0","  for (dist_method in names(evaluations)) {"
"0","    for (clustering_type in c(""macro"", ""micro"")) {"
"0","      for (method_name in names(evaluations[[dist_method]][[clustering_type]])) {"
"0","        for (k_name in names(evaluations[[dist_method]][[clustering_type]][[method_name]])) {"
"0","          "
"0","          result <- evaluations[[dist_method]][[clustering_type]][[method_name]][[k_name]]"
"0","          "
"0","          if (!is.null(result)) {"
"0","            metrics_data <- rbind(metrics_data, data.frame("
"0","              distance_method = dist_method,"
"0","              clustering_type = clustering_type,"
"0","              clustering_method = method_name,"
"0","              k = result$k,"
"0","              within_dissim = result$quality$within_cluster_dissim,"
"0","              separation = result$quality$separation,"
"0","              entropy = result$quality$entropy, "
"0","              pearson_gamma = result$quality$pearson_gamma,"
"0","              bootstrap_stability = result$quality$bootstrap_stability,"
"0","              n_clusters_actual = result$quality$n_clusters,"
"0","              stringsAsFactors = FALSE"
"0","            ))"
"0","          }"
"0","        }"
"0","      }"
"0","    }"
"0","  }"
"0","  "
"0","  return(metrics_data)"
"0","}"
"0",""
"0","# Extract metrics for calibration"
"0","all_metrics <- extract_quality_metrics(clustering_evaluations)"
"0",""
"0","cat(sprintf(""✓ Extracted %d clustering evaluations for calibration\\n"", nrow(all_metrics)))"
"1","✓ Extracted 220 clustering evaluations for calibration\n"
"0","# Calibration function (simplified version of Akhanli & Hennig approach)"
"0","calibrate_metrics <- function(metrics_df, calibration_type = ""global"") {"
"0","  "
"0","  cat(sprintf(""→ Calibrating metrics using %s approach...\\n"", calibration_type))"
"0","  "
"0","  calibrated_df <- metrics_df"
"0","  "
"0","  # Standardize each metric (excluding bootstrap_stability if NA)"
"0","  metrics_to_calibrate <- c(""within_dissim"", ""separation"", ""entropy"", ""pearson_gamma"")"
"0","  "
"0","  for (metric in metrics_to_calibrate) {"
"0","    values <- metrics_df[[metric]]"
"0","    "
"0","    if (calibration_type == ""global"") {"
"0","      # Global standardization across all clusterings"
"0","      calibrated_df[[paste0(metric, ""_calibrated"")]] <- scale(values)[, 1]"
"0","      "
"0","    } else if (calibration_type == ""by_k"") {"
"0","      # Standardization within each K value"
"0","      calibrated_values <- rep(NA, length(values))"
"0","      for (k_val in unique(metrics_df$k)) {"
"0","        k_indices <- which(metrics_df$k == k_val)"
"0","        if (length(k_indices) > 1) {"
"0","          calibrated_values[k_indices] <- scale(values[k_indices])[, 1]"
"0","        } else {"
"0","          calibrated_values[k_indices] <- 0"
"0","        }"
"0","      }"
"0","     calibrated_df[[paste0(metric, ""_calibrated"")]] <- calibrated_values"
"0","   }"
"0"," }"
"0"," "
"0"," # Handle bootstrap stability separately (if available)"
"0"," if (!all(is.na(metrics_df$bootstrap_stability))) {"
"0","   stability_values <- metrics_df$bootstrap_stability"
"0","   stability_values[is.na(stability_values)] <- mean(stability_values, na.rm = TRUE)"
"0","   "
"0","   if (calibration_type == ""global"") {"
"0","     calibrated_df$bootstrap_stability_calibrated <- scale(stability_values)[, 1]"
"0","   } else {"
"0","     calibrated_values <- rep(NA, length(stability_values))"
"0","     for (k_val in unique(metrics_df$k)) {"
"0","       k_indices <- which(metrics_df$k == k_val)"
"0","       if (length(k_indices) > 1) {"
"0","         calibrated_values[k_indices] <- scale(stability_values[k_indices])[, 1]"
"0","       } else {"
"0","         calibrated_values[k_indices] <- 0"
"0","       }"
"0","     }"
"0","     calibrated_df$bootstrap_stability_calibrated <- calibrated_values"
"0","   }"
"0"," } else {"
"0","   calibrated_df$bootstrap_stability_calibrated <- 0"
"0"," }"
"0"," "
"0"," return(calibrated_df)"
"0","}"
"0",""
"0","# Calibrate metrics for both macro and micro clustering"
"0","macro_metrics <- all_metrics[all_metrics$clustering_type == ""macro"", ]"
"0","micro_metrics <- all_metrics[all_metrics$clustering_type == ""micro"", ]"
"0",""
"0","calibrated_macro <- calibrate_metrics(macro_metrics, ""global"")"
"1","→ Calibrating metrics using global approach...\n"
"0","calibrated_micro <- calibrate_metrics(micro_metrics, ""by_k"")"
"1","→ Calibrating metrics using by_k approach...\n"
"0","# Define composite index weights (following Akhanli & Hennig philosophy)"
"0",""
"0","# Macro clustering weights (policy-oriented)"
"0","MACRO_WEIGHTS <- list("
"0"," within_dissim = 1.0,      # Primary: homogeneous resilience profiles"
"0"," separation = 0.5,         # Secondary: meaningful gaps between profiles  "
"0"," entropy = 1.0,            # Important: balanced profile sizes"
"0"," pearson_gamma = 1.0,      # Important: represents data structure"
"0"," bootstrap_stability = 1.0 # Important: replicable profiles"
"0",")"
"0",""
"0","# Micro clustering weights (intervention-oriented)"
"0","MICRO_WEIGHTS <- list("
"0"," within_dissim = 1.0,      # Primary: precise student similarity"
"0"," separation = 0.3,         # Less important: fine-grained differences"
"0"," entropy = 0.8,            # Somewhat important: avoid tiny clusters"
"0"," pearson_gamma = 0.5,      # Less important: focus on homogeneity"
"0"," bootstrap_stability = 1.2 # Very important: stable intervention groups"
"0",")"
"0",""
"0","# Calculate composite indexes"
"0","calculate_composite_index <- function(calibrated_df, weights) {"
"0"," "
"0"," # Note: within_dissim should be negated (smaller is better)"
"0"," composite_scores <- ("
"0","   -weights$within_dissim * calibrated_df$within_dissim_calibrated +"
"0","   weights$separation * calibrated_df$separation_calibrated +"
"0","   weights$entropy * calibrated_df$entropy_calibrated +"
"0","   weights$pearson_gamma * calibrated_df$pearson_gamma_calibrated +"
"0","   weights$bootstrap_stability * calibrated_df$bootstrap_stability_calibrated"
"0"," ) / sum(unlist(weights))"
"0"," "
"0"," return(composite_scores)"
"0","}"
"0",""
"0","# Calculate composite indexes"
"0","calibrated_macro$composite_index <- calculate_composite_index(calibrated_macro, MACRO_WEIGHTS)"
"0","calibrated_micro$composite_index <- calculate_composite_index(calibrated_micro, MICRO_WEIGHTS)"
"0",""
"0","cat(""✓ Composite indexes calculated\\n"")"
"1","✓ Composite indexes calculated\n"
"0","cat(sprintf(""✓ Macro clustering: %.3f to %.3f\\n"", "
"0","           min(calibrated_macro$composite_index), max(calibrated_macro$composite_index)))"
"1","✓ Macro clustering: -0.790 to 0.354\n"
"0","cat(sprintf(""✓ Micro clustering: %.3f to %.3f\\n"", "
"0","           min(calibrated_micro$composite_index), max(calibrated_micro$composite_index)))"
"1","✓ Micro clustering: -0.413 to 0.343\n"
